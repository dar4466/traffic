#!./.mnist-keras/bin/python
import collections
import math
import os
#import tensorflow as tf
import docker
import fire
#import torch
import json
import os
import os

#os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'


import docker
import fire
import numpy as np
#import tensorflow as tf


#import numpy as np
import random
#import os
#import cv2 as cv
#import matplotlib.pyplot as plt
#from sklearn.model_selection import train_test_split
import tensorflow as tf
from fedn.utils.helpers.helpers import get_helper, save_metadata, save_metrics

HELPER_MODULE = 'numpyhelper'
helper = get_helper(HELPER_MODULE)

NUM_CLASSES = 10


def _get_data_path():
    # Figure out FEDn client number from container name
    client = docker.from_env()
    container = client.containers.get(os.environ['HOSTNAME'])
    number = container.name[-1]
    #number=1
    # Return data path
    return f"/var/data/clients/{number}/traffic.npz"


def _compile_model(img_rows=32, img_cols=32):
    # Set input shape
    input_shape = (img_rows, img_cols, 3)
    ##DEFINE MODEL###
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.Rescaling(1,input_shape=input_shape))
    model.add(tf.keras.layers.Conv2D(filters=6, kernel_size=(5,5), activation='relu'))
    model.add(tf.keras.layers.AveragePooling2D(pool_size=(2,2)))
    model.add(tf.keras.layers.Conv2D(filters=16, kernel_size=(5,5), activation='relu'))
    model.add(tf.keras.layers.AveragePooling2D(pool_size=(2,2)))
    model.add(tf.keras.layers.Conv2D(filters=120, kernel_size=(5,5), activation='relu'))
    model.add(tf.keras.layers.Dropout(0.2))
    model.add(tf.keras.layers.Flatten())
    model.add(tf.keras.layers.Dense(120, activation='relu'))
    model.add(tf.keras.layers.Dense(43, activation='softmax'))
    model.compile(loss=tf.keras.losses.categorical_crossentropy,optimizer=tf.keras.optimizers.Adam(), metrics=['accuracy'])

    return model

def _load_data(data_path, is_train=True):
    # Load data
    if data_path is None:
        data = np.load(_get_data_path())
    else:
        data = np.load(data_path)

    if is_train:
        X = data['x_train']
        y = data['y_train']
    else:
        X = data['x_test']
        y = data['y_test']

    # Normalize
    X = X / 255
    X = X.astype(np.float32)
    y = y.astype(np.float32)
   # X = np.expand_dims(X, -1)
   # X = X / 255
   # y = tf.keras.utils.to_categorical(y, NUM_CLASSES)

    return X, y



def init_seed(out_path='seed.npz'):
    weights = _compile_model().get_weights()
    helper.save(weights, out_path)

def save_parameters(model, out_path):
    """ Save model parameters to file.

    :param model: The model to serialize.
    :type model: torch.nn.Module
    :param out_path: The path to save to.
    :type out_path: str
    """
    parameters_np = [val.cpu().numpy() for _, val in model.state_dict().items()]
    helper.save(parameters_np, out_path)


def load_parameters(model_path):
    """ Load model parameters from file and populate model.

    param model_path: The path to load from.
    :type model_path: str
    :return: The loaded model.
    :rtype: torch.nn.Module
    """
    model = compile_model()
    parameters_np = helper.load(model_path)

    params_dict = zip(model.state_dict().keys(), parameters_np)
    state_dict = collections.OrderedDict({key: torch.tensor(x) for key, x in params_dict})
    model.load_state_dict(state_dict, strict=True)
    return model

def train(in_model_path, out_model_path, data_path=None, batch_size=32, epochs=1):
    # Load data
    x_train, y_train = _load_data(data_path)

    # Load model
    model = _compile_model()
    weights = helper.load(in_model_path)
    model.set_weights(weights)

    # Train
    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs)

    # Save
    weights = model.get_weights()
    helper.save(weights, out_model_path)
    
    # Metadata needed for aggregation server side
    metadata = {
        # num_examples are mandatory
        'num_examples': len(x_train),
        'batch_size': batch_size,
        'epochs': epochs
    }

    # Save JSON metadata file (mandatory)
    save_metadata(metadata, out_model_path)

    # Save model update (mandatory)
    # save_parameters(model, out_model_path)


def validate(in_model_path, out_json_path, data_path=None):
    # Load data
    x_train, y_train = _load_data(data_path)
    x_test, y_test = _load_data(data_path, is_train=False)

    # Load model
    model = _compile_model()
    weights = helper.load(in_model_path)
    model.set_weights(weights)

    # Evaluate
    model_score = model.evaluate(x_train, y_train)
    model_score_test = model.evaluate(x_test, y_test)
    y_pred = model.predict(x_test)
    y_pred = np.argmax(y_pred, axis=1)

    # JSON schema
    report = {
        "training_loss": model_score[0],
        "training_accuracy": model_score[1],
        "test_loss": model_score_test[0],
        "test_accuracy": model_score_test[1],
    }

    # Save JSON
    with open(out_json_path, "w") as fh:
        fh.write(json.dumps(report))


if __name__ == '__main__':
    fire.Fire({
        'init_seed': init_seed,
        'train': train,
        'validate': validate,
        '_get_data_path': _get_data_path,  # for testing
    })
    
    
